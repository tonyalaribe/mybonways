package actions

import (
	"net/http"

	"log"

	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/buffalo/render"
	"github.com/markbates/pop"
	"github.com/pkg/errors"
	"github.com/tonyalaribe/mybonways/models"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Reservation)
// DB Table: Plural (Reservations)
// Resource: Plural (Reservations)
// Path: Plural (/reservations)
// View Template Folder: Plural (/templates/reservations/)

// ReservationsResource is the resource for the reservation model
type ReservationsResource struct {
	buffalo.Resource
}

// List gets all Reservations. This function is mapped to the path
// GET /reservations
func (v ReservationsResource) List(c buffalo.Context) error {
	// Get the DB connection from the context
	tx := c.Value("tx").(*pop.Connection)
	reservations := &[]models.ReservationStruct{}
	user := c.Value("user").(map[string]interface{})

	// You can order your list here. Just change
	// err := tx.Where("user_id = ?", user["id"]).All(reservations)
	err := tx.RawQuery(`SELECT id, created_at, updated_at, user_id, promo_id, promo_slug,
	item_name, company_id, category, old_price, new_price, start_date, end_date, description,
	promo_images, featured_image, code, featured_image_b64, slug, company_id as cid FROM reservations r
	LEFT OUTER JOIN (
		SELECT id as pid, item_name, category, old_price, new_price, start_date, end_date, description,
		promo_images, featured_image, featured_image_b64, slug FROM merchant_promos
	) p
	ON r.promo_id = p.pid WHERE r.user_id = ? ORDER BY r.created_at DESC;`, user["id"]).All(reservations)
	// to:
	// err := tx.Order("create_at desc").All(reservations)
	if err != nil {
		return errors.WithStack(err)
	}
	return c.Render(http.StatusOK, render.JSON(reservations))
}

// Show gets the data for one Reservation. This function is mapped to
// the path GET /reservations/{reservation_id}
func (v ReservationsResource) Show(c buffalo.Context) error {
	// Get the DB connection from the context
	tx := c.Value("tx").(*pop.Connection)
	// Allocate an empty Reservation
	reservation := &models.Reservation{}
	// To find the Reservation the parameter reservation_id is used.
	err := tx.Find(reservation, c.Param("reservation_id"))
	if err != nil {
		return errors.WithStack(err)
	}
	// Make reservation available inside the html template
	c.Set("reservation", reservation)
	return c.Render(200, r.HTML("reservations/show.html"))
}

// New renders the formular for creating a new reservation.
// This function is mapped to the path GET /reservations/new
func (v ReservationsResource) New(c buffalo.Context) error {
	// Make reservation available inside the html template
	c.Set("reservation", &models.Reservation{})
	return c.Render(200, r.HTML("reservations/new.html"))
}

// Create adds a reservation to the DB. This function is mapped to the
// path POST /reservations
func (v ReservationsResource) Create(c buffalo.Context) error {
	// Allocate an empty Reservation
	reservation := &models.Reservation{}
	// Bind reservation to the html form elements
	err := c.Bind(reservation)
	if err != nil {
		return errors.WithStack(err)
	}

	reservation.Code = RandStringBytes(5)
	reservation.Status = "pending"
	// Get the DB connection from the context
	tx := c.Value("tx").(*pop.Connection)
	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(reservation)
	if err != nil {
		return c.Error(http.StatusInternalServerError, errors.WithStack(err))
	}
	if verrs.HasAny() {
		// Make reservation available inside the html template
		c.Set("reservation", reservation)
		// Make the errors available inside the html template
		c.Set("errors", verrs)
		// Render again the new.html template that the user can
		// correct the input.
		return c.Render(422, r.HTML("reservations/new.html"))
	}

	return c.Render(http.StatusOK, render.JSON(reservation))
}

// Edit renders a edit formular for a reservation. This function is
// mapped to the path GET /reservations/{reservation_id}/edit
func (v ReservationsResource) Edit(c buffalo.Context) error {
	// Get the DB connection from the context
	tx := c.Value("tx").(*pop.Connection)
	// Allocate an empty Reservation
	reservation := &models.Reservation{}
	err := tx.Find(reservation, c.Param("reservation_id"))
	if err != nil {
		return errors.WithStack(err)
	}
	// Make reservation available inside the html template
	c.Set("reservation", reservation)
	return c.Render(200, r.HTML("reservations/edit.html"))
}

// Update changes a reservation in the DB. This function is mapped to
// the path PUT /reservations/{reservation_id}
func (v ReservationsResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	tx := c.Value("tx").(*pop.Connection)
	// Allocate an empty Reservation
	reservation := &models.Reservation{}
	err := tx.Find(reservation, c.Param("reservation_id"))
	if err != nil {
		return errors.WithStack(err)
	}
	// Bind reservation to the html form elements
	err = c.Bind(reservation)
	if err != nil {
		return errors.WithStack(err)
	}
	verrs, err := tx.ValidateAndUpdate(reservation)
	if err != nil {
		return errors.WithStack(err)
	}
	if verrs.HasAny() {
		// Make reservation available inside the html template
		c.Set("reservation", reservation)
		// Make the errors available inside the html template
		c.Set("errors", verrs)
		// Render again the edit.html template that the user can
		// correct the input.
		return c.Render(422, r.HTML("reservations/edit.html"))
	}
	// If there are no errors set a success message
	c.Flash().Add("success", "Reservation was updated successfully")
	// and redirect to the reservations index page
	return c.Redirect(302, "/reservations/%s", reservation.ID)
}

// Destroy deletes a reservation from the DB. This function is mapped
// to the path DELETE /reservations/{reservation_id}
func (v ReservationsResource) Destroy(c buffalo.Context) error {
	// Get the DB connection from the context
	tx := c.Value("tx").(*pop.Connection)
	// Allocate an empty Reservation
	reservation := &models.Reservation{}
	// To find the Reservation the parameter reservation_id is used.
	log.Printf("\n\nreservation_id: %#v\n\n", c.Param("/_id"))
	err := tx.Find(reservation, c.Param("/_id"))
	if err != nil {
		return errors.WithStack(err)
	}
	err = tx.Destroy(reservation)
	if err != nil {
		return errors.WithStack(err)
	}
	return c.Render(http.StatusOK, render.JSON(reservation))
}

func (v ReservationsResource) isReserved(c buffalo.Context) error {
	// Get the DB connection from the context
	tx := c.Value("tx").(*pop.Connection)
	// Allocate an empty Reservation
	reservation := &models.Reservation{}
	userID := c.Param("promo_id")
	// To find the Reservation the parameter reservation_id is used.
	err := tx.Where("promo_id = ? AND status = 'pending'", userID).First(reservation)
	if err != nil {
		return c.Render(422, render.JSON(reservation))
	}

	return c.Render(http.StatusOK, render.JSON(reservation))
}

func (v ReservationsResource) GetMerchantReservations(c buffalo.Context) error {
	// Get the DB connection from the context
	tx := c.Value("tx").(*pop.Connection)
	reservations := &[]models.MerchantReservationStruct{}
	merchant := c.Value("Merchant").(map[string]interface{})

	// You can order your list here. Just change
	// err := tx.Where("user_id = ?", user["id"]).All(reservations)
	err := tx.RawQuery(`SELECT id, created_at, updated_at, user_id,
	promo_id, promo_slug, company_id, code, item_name, email, status
	FROM reservations r
		LEFT OUTER JOIN ( SELECT id as pid, item_name FROM merchant_promos ) p ON r.promo_id = p.pid
		LEFT OUTER JOIN ( SELECT id as uid, email FROM users ) u ON r.user_id = u.uid
	WHERE r.company_id = ? ORDER BY r.created_at DESC;`, merchant["company_id"]).All(reservations)
	// to:
	// err := tx.Order("create_at desc").All(reservations)
	if err != nil {
		return errors.WithStack(err)
	}
	return c.Render(http.StatusOK, render.JSON(reservations))
}

func (v ReservationsResource) ClaimReservation(c buffalo.Context) error {
	tx := c.Value("tx").(*pop.Connection)
	reservationID := c.Param("reservation_id")
	promoID := c.Param("promo_id")
	err := tx.RawQuery("UPDATE reservations SET status = 'claimed' WHERE id = ?;", reservationID).Exec()
	if err != nil {
		return errors.WithStack(err)
	}
	err = tx.RawQuery("UPDATE merchant_promos SET quantity = quantity - 1 WHERE id = ? AND quantity > 0;", promoID).Exec()
	if err != nil {
		return errors.WithStack(err)
	}
	merchant := c.Value("Merchant").(map[string]interface{})
	reservations := &[]models.MerchantReservationStruct{}
	err = tx.RawQuery(`SELECT id, created_at, updated_at, user_id,
	promo_id, promo_slug, company_id, code, item_name, email, status
	FROM reservations r
		LEFT OUTER JOIN ( SELECT id as pid, item_name FROM merchant_promos ) p ON r.promo_id = p.pid
		LEFT OUTER JOIN ( SELECT id as uid, email FROM users ) u ON r.user_id = u.uid
	WHERE r.company_id = ? ORDER BY r.created_at DESC;`, merchant["company_id"]).All(reservations)
	if err != nil {
		return errors.WithStack(err)
	}
	return c.Render(http.StatusOK, render.JSON(reservations))
}
